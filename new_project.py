import os, shutil, datetime, re, platform, itertools
from string import Template
from git import Repo, Submodule
from utils import panic
from typing import List


def new_project(project):
    """Creates a new C++ project."""

    name = os.path.basename(project.path)

    repo = generate_repo(path=project.path,
                         git_choice=project.git,
                         package_manager=project.package_manager,
                         package_manager_remote=project.package_manager_remote)
    generate_clang_dotfiles(repo=repo, project_name=name, path=project.path)
    generate_documentation(repo=repo,
                           project_name=name,
                           author=project.author,
                           remote=project.git,
                           path=project.path)

    if project.package_manager == 'vcpkg':
        generate_vcpkg(repo=repo,
                       path=project.path,
                       project_name=name,
                       remote=project.package_manager_remote)

    if project.build_system == 'cmake':
        toolchains = generate_cmake(
            repo=repo,
            project_name=name,
            path=project.path,
            cxx_standard=project.std,
            exceptions=not project.fno_exceptions,
            rtti=not project.fno_rtti,
            toolchain_prefix=project.prefix,
            vcpkg_enabled=project.package_manager == 'vcpkg')

    generate_editor(repo=repo,
                    path=project.path,
                    editor=project.editor,
                    project_name=name,
                    using_cmake=project.build_system == 'cmake',
                    toolchains=toolchains or [])

    repo.index.commit(
        'initial commit\n\nThis commit was generated by new-c++-project.py.')
    return


def generate_repo(path: str, git_choice: str, package_manager: str,
                  package_manager_remote: str) -> Repo:
    if os.path.exists(path):
        panic(f"path '{path}' already exists")

    print(f'Creating repo at {path}')
    repo = Repo.init(path=path, mkdir=True)
    repo.active_branch.rename('main')
    if git_choice.endswith('.git'):
        repo.create_remote(name='origin', url=f'{git_choice}')

    shutil.copy('templates/.gitignore', path)
    repo.index.add(f'{path}/.gitignore')
    return repo


def generate_editor(repo: Repo, path: str, editor: str, project_name: str,
                    using_cmake: bool, toolchains: List[str]):
    if editor == 'none':
        return []

    if editor == 'vscode':
        generate_vscode(repo=repo,
                        path=path,
                        project_name=project_name,
                        using_cmake=using_cmake,
                        toolchains=toolchains)


def substitute_templates(replace,
                         template: str,
                         prefix: str,
                         rename: str = None) -> str:
    with open(f'templates/{template}') as f:
        data = Template(f.read())

    suffix = template if not rename else os.path.join(
        os.path.dirname(template), rename)
    path = f'{prefix}/{suffix}'
    with open(path, 'w') as f:
        f.write(re.sub('^\s+$', '', data.substitute(replace)))
    return path


def generate_vscode(repo: Repo, path: str, project_name: str,
                    using_cmake: bool, toolchains: List[str]):
    print('Copying VS Code files')
    vscode_dir = f'{path}/.vscode'
    os.mkdir(vscode_dir)

    vscode_templates = 'templates/.vscode'
    shutil.copy(f'{vscode_templates}/launch.json', vscode_dir)
    shutil.copy(f'{vscode_templates}/settings.json', vscode_dir)

    if using_cmake:
        cmake_kits_json = 'cmake-kits.json'
        with open(f'{vscode_templates}/cmake-kits.json') as f:
            cmake_kits = Template(f.read())
        cmake_enabled = ',\n'.join(
            map(
                lambda toolchain: cmake_kits.substitute(
                    {
                        'project_name': project_name,
                        'config_name': toolchain[0],
                        'toolchain': toolchain[1],
                        'enable_clang_tidy': 'On'
                    }).strip(), toolchains))
        cmake_disabled = ',\n'.join(
            map(
                lambda toolchain: cmake_kits.substitute(
                    {
                        'project_name': project_name,
                        'config_name': toolchain[0],
                        'toolchain': toolchain[1],
                        'enable_clang_tidy': 'Off'
                    }).strip(), toolchains))
        with open(f'{vscode_dir}/{cmake_kits_json}', 'w') as f:
            f.write('[\n  ')
            f.write(cmake_enabled)
            f.write(',\n  ')
            f.write(cmake_disabled)
            f.write('\n]')

    repo.index.add(vscode_dir)


def generate_clang_dotfiles(repo: Repo, path: str, project_name: str):
    print('Copying clang-tools dotfiles')

    dot_clang_format = '.clang-format'
    shutil.copy(f'templates/{dot_clang_format}', path)
    dot_clangd = '.clangd'
    shutil.copy(f'templates/{dot_clangd}', path)

    dot_clang_tidy = '.clang-tidy'
    dot_clang_tidy = substitute_templates(
        template=f'{dot_clang_tidy}',
        prefix=path,
        replace={'project_name': project_name},
    )

    repo.index.add([dot_clang_format, dot_clangd, dot_clang_tidy])


def get_remote(remote: str) -> str:
    if not remote:
        return ''
    if 'github.com' in remote:
        text = '[GitHub]'
    elif 'gitlab.com' in remote:
        text = '[GitLab]'
    else:
        return 'our Git repo'

    if (remote.startswith('https://') or remote.startswith('http://')):
        return remote

    remote = re.sub(':', '/', remote)
    remote = re.sub('^(git(@|:\/\/))', 'https://', remote)
    remote = re.sub('.git$', '', remote)
    return f'{text}({remote})'


def generate_documentation(repo: Repo, project_name: str, author: str,
                           remote: str, path: str):
    print('Generating documentation')
    shutil.copy('templates/README.md', path)
    paths = [f'{path}/README.md']
    paths.append(
        substitute_templates(
            template='LICENCE',
            prefix=path,
            replace={
                'project_name': project_name,
                'copyright_holder': author,
                'year': datetime.date.today().year,
            },
        ))

    paths.append(
        substitute_templates(
            template='CODE_OF_CONDUCT.md',
            prefix=path,
            replace={
                'project_name': project_name,
                'remote': get_remote(remote)
            },
        ))

    teams = 'docs/project/teams'
    paths.append(f'{path}/{teams}')
    os.makedirs(f'{path}/{teams}')
    shutil.copy(f'templates/{teams}/conduct_teams.md', f'{path}/{teams}')
    substitute_templates(
        template=f'{teams}/leads.md',
        prefix=f'{path}',
        replace={
            'project_name': project_name,
        },
    )

    repo.index.add(paths)


def generate_cmake(repo: Repo, project_name: str, path: str, cxx_standard,
                   exceptions: bool, rtti: bool, toolchain_prefix,
                   vcpkg_enabled: bool) -> List[str]:
    paths = []
    paths.append(
        substitute_templates(
            template='CMakeLists.txt',
            prefix=path,
            replace={
                'project_name': project_name,
                'cxx_standard': cxx_standard
            },
        ))

    root = 'config/cmake'
    paths.append(f'{path}/{root}')
    os.makedirs(f'{path}/{root}/toolchains')

    substitute_templates(
        template=f'{root}/add_targets.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/FindClangTidy.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/FindStdModules.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/add_packages.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/handle_options.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/handle_options_impl.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )

    target = 'x86_64'
    triple = 'x86_64-unknown-linux-gnu'
    toolchains = [
        ('GCC', f'{triple}-gcc'),
        ('Clang (GNU toolchain)', f'{triple}-clang-with-gnu-toolchain'),
        ('Clang (LLVM toolchain)', f'{triple}-clang-with-llvm-toolchain'),
    ]
    gnu_toolchain = {
        'system_name': platform.system(),
        'target': target,
        'triple': triple,
        'prefix': toolchain_prefix,
        'cc': 'gcc',
        'cxx': 'g++',
        'ar': 'ar',
        'rc': 'rc',
        'ranlib': 'ranlib',
        'stdlib': '',
        'hardening': '',
        'libunwind': '',
        'compiler_rt': '',
        'linker': '-fuse-ld=gold',
        'exceptions': '-fno-exceptions' if not exceptions else '',
        'rtti': '-fno-rtti' if not rtti else '',
    }
    substitute_templates(rename=f'{toolchains[0][1]}.cmake',
                         template=f'{root}/toolchains/toolchain_base.cmake',
                         prefix=path,
                         replace=gnu_toolchain)

    clang_with_gnu_toolchain = gnu_toolchain
    clang_with_gnu_toolchain['cc'] = 'clang'
    clang_with_gnu_toolchain['cxx'] = 'clang++'
    clang_with_gnu_toolchain['stdlib'] = '-stdlib=libstdc++'
    substitute_templates(rename=f'{toolchains[1][1]}.cmake',
                         template=f'{root}/toolchains/toolchain_base.cmake',
                         prefix=path,
                         replace=clang_with_gnu_toolchain)

    llvm_toolchain = {
        'system_name': platform.system(),
        'target': target,
        'triple': triple,
        'prefix': toolchain_prefix,
        'cc': 'clang',
        'cxx': 'clang++',
        'ar': 'llvm-ar',
        'rc': 'llvm-rc',
        'ranlib': 'llvm-ranlib',
        'stdlib': '-stdlib=libc++',
        'hardening': '-D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_FAST',
        'libunwind': '-unwindlib=libunwind',
        'compiler_rt': '-rtlib=compiler-rt',
        'linker': '-fuse-ld=lld',
        'exceptions': '-fno-exceptions' if not exceptions else '',
        'rtti': '-fno-rtti' if not rtti else '',
    }
    substitute_templates(rename=f'{toolchains[2][1]}.cmake',
                         template=f'{root}/toolchains/toolchain_base.cmake',
                         prefix=path,
                         replace=llvm_toolchain)

    if vcpkg_enabled:
        vcpkg_root = 'config/vcpkg/cmake/toolchains'
        paths.append(vcpkg_root)
        os.makedirs(f'{path}/{vcpkg_root}')

        triplet_name = 'triplet_name'
        gnu_toolchain[triplet_name] = toolchains[0][1]
        clang_with_gnu_toolchain[triplet_name] = toolchains[1][1]
        llvm_toolchain[triplet_name] = toolchains[2][1]

        lto = 'lto'
        gnu_toolchain[lto] = '-flto'
        clang_with_gnu_toolchain[lto] = '-flto=thin'
        llvm_toolchain[lto] = '-flto=thin'

        substitute_templates(rename=f'{toolchains[0][1]}.cmake',
                             template=f'{vcpkg_root}/toolchain_base.cmake',
                             prefix=path,
                             replace=gnu_toolchain)
        substitute_templates(rename=f'{toolchains[1][1]}.cmake',
                             template=f'{vcpkg_root}/toolchain_base.cmake',
                             prefix=path,
                             replace=clang_with_gnu_toolchain)
        substitute_templates(rename=f'{toolchains[2][1]}.cmake',
                             template=f'{vcpkg_root}/toolchain_base.cmake',
                             prefix=path,
                             replace=llvm_toolchain)

    repo.index.add(paths)
    return toolchains


def generate_vcpkg(path: str, repo: Repo, project_name: str, remote: str):
    print('Acquiring vcpkg')
    vcpkg = Submodule.add(repo, 'vcpkg', path=f'{path}/vcpkg', url=remote)
    vcpkg.update(recursive=True, init=True, to_latest_revision=True)

    repo.index.add(
        substitute_templates(
            template='vcpkg.json',
            prefix=path,
            replace={'project_name': project_name},
        ))
