import os, shutil, datetime, re, platform, itertools
from string import Template
from git import Repo, Submodule
from utils import panic
from typing import List


def new_project(project):
    """Creates a new C++ project."""

    name = os.path.basename(project.path)

    repo = generate_repo(path=project.path,
                         remote=project.remote,
                         package_manager=project.package_manager,
                         package_manager_remote=project.package_manager_remote)
    generate_clang_dotfiles(repo=repo, project_name=name, path=project.path)
    generate_documentation(repo=repo,
                           project_name=name,
                           author=project.author,
                           remote=project.remote,
                           path=project.path)

    if project.package_manager == 'vcpkg':
        generate_vcpkg(repo=repo,
                       path=project.path,
                       project_name=name,
                       remote=project.package_manager_remote)

    toolchains = generate_cmake(
        repo=repo,
        project_name=name,
        path=project.path,
        cxx_standard=project.std,
        exceptions=not project.fno_exceptions,
        rtti=not project.fno_rtti,
        toolchain_prefix=project.toolchain_prefix,
        vcpkg_enabled=project.package_manager == 'vcpkg')

    generate_editor(repo=repo,
                    path=project.path,
                    editor=project.editor,
                    project_name=name,
                    toolchains=toolchains or [])

    repo.index.commit(
        'initial commit\n\nThis commit was generated by new-c++-project.py.')
    return


def generate_repo(path: str, remote: str, package_manager: str,
                  package_manager_remote: str) -> Repo:
    if os.path.exists(path):
        panic(f"path '{path}' already exists")

    print(f'Creating repo at {path}')
    repo = Repo.init(path=path, mkdir=True)
    repo.active_branch.rename('main')
    if remote.startswith('file://'):
        repo.create_remote(name='origin', url=f'{remote[len("file://"):]}')
    elif remote.endswith('.git'):
        repo.create_remote(name='origin', url=f'{remote}')

    shutil.copy('templates/.gitignore', path)
    repo.index.add(f'{path}/.gitignore')
    return repo


def generate_editor(repo: Repo, path: str, editor: str, project_name: str,
                    toolchains: dict):
    if editor == 'none':
        return []

    if editor == 'vscode':
        generate_vscode(repo=repo,
                        path=path,
                        project_name=project_name,
                        toolchains=toolchains)


def substitute_templates(replace,
                         template: str,
                         prefix: str,
                         rename: str = None) -> str:
    with open(f'templates/{template}') as f:
        data = Template(f.read())

    suffix = template if not rename else os.path.join(
        os.path.dirname(template), rename)
    path = f'{prefix}/{suffix}'
    with open(path, 'w') as f:
        f.write(re.sub('^\s+$', '', data.substitute(replace)))
    return path


def generate_vscode(repo: Repo, path: str, project_name: str,
                    toolchains: dict):
    print('Copying VS Code files')
    vscode_dir = f'{path}/.vscode'
    os.mkdir(vscode_dir)

    vscode_templates = 'templates/.vscode'
    shutil.copy(f'{vscode_templates}/launch.json', vscode_dir)
    shutil.copy(f'{vscode_templates}/settings.json', vscode_dir)

    cmake_kits_json = 'cmake-kits.json'
    with open(f'{vscode_templates}/cmake-kits.json') as f:
        cmake_kits = Template(f.read())

    entries = []
    for (_, toolchain) in toolchains.items():
        entries.append(
            cmake_kits.substitute({
                'project_name': project_name,
                'config_name': toolchain['name'],
                'description': toolchain['toolchain'],
                'toolchain': make_triplet(toolchain),
                'triple': toolchain['triple'],
                'enable_clang_tidy': 'On',
            }).strip())
        entries.append(
            cmake_kits.substitute({
                'project_name': project_name,
                'config_name': toolchain['name'],
                'description': toolchain['toolchain'],
                'toolchain': make_triplet(toolchain),
                'triple': toolchain['triple'],
                'enable_clang_tidy': 'Off',
            }).strip())

    with open(f'{vscode_dir}/{cmake_kits_json}', 'w') as f:
        to_join = ',\n  '  # escape sequences aren't allowed in f-strings
        f.write(f'[\n  {to_join.join(entries)}\n]')

    repo.index.add(vscode_dir)


def make_triplet(toolchain):
    return f'{toolchain["triple"]}-{toolchain["suffix"]}'


def generate_clang_dotfiles(repo: Repo, path: str, project_name: str):
    print('Copying clang-tools dotfiles')

    dot_clang_format = '.clang-format'
    shutil.copy(f'templates/{dot_clang_format}', path)
    dot_clangd = '.clangd'
    shutil.copy(f'templates/{dot_clangd}', path)

    dot_clang_tidy = '.clang-tidy'
    dot_clang_tidy = substitute_templates(
        template=f'{dot_clang_tidy}',
        prefix=path,
        replace={'project_name': project_name},
    )

    repo.index.add([dot_clang_format, dot_clangd, dot_clang_tidy])


def get_remote(remote: str) -> str:
    if not remote:
        return ''
    if 'github.com' in remote:
        text = '[GitHub]'
    elif 'gitlab.com' in remote:
        text = '[GitLab]'
    else:
        return 'our Git repo'

    if (remote.startswith('https://') or remote.startswith('http://')):
        return remote

    remote = re.sub(':', '/', remote)
    remote = re.sub('^(git(@|:\/\/))', 'https://', remote)
    remote = re.sub('.git$', '', remote)
    return f'{text}({remote})'


def generate_documentation(repo: Repo, project_name: str, author: str,
                           remote: str, path: str):
    print('Generating documentation')
    paths = []
    paths.append(
        substitute_templates(
            template='README.md',
            prefix=path,
            replace={'project_name': project_name},
        ))
    paths.append(
        substitute_templates(
            template='LICENCE',
            prefix=path,
            replace={
                'project_name': project_name,
                'copyright_holder': author,
                'year': datetime.date.today().year,
            },
        ))

    paths.append(
        substitute_templates(
            template='CODE_OF_CONDUCT.md',
            prefix=path,
            replace={
                'project_name': project_name,
                'remote': get_remote(remote)
            },
        ))

    teams = 'docs/project/teams'
    paths.append(f'{path}/{teams}')
    os.makedirs(f'{path}/{teams}')
    shutil.copy(f'templates/{teams}/conduct_teams.md', f'{path}/{teams}')
    substitute_templates(
        template=f'{teams}/leads.md',
        prefix=f'{path}',
        replace={
            'project_name': project_name,
        },
    )

    repo.index.add(paths)


def generate_cmake(repo: Repo, project_name: str, path: str, cxx_standard,
                   exceptions: bool, rtti: bool, toolchain_prefix,
                   vcpkg_enabled: bool) -> List[str]:
    paths = []
    paths.append(
        substitute_templates(
            template='CMakeLists.txt',
            prefix=path,
            replace={
                'project_name': project_name,
                'cxx_standard': cxx_standard[-2:],
                'extensions':
                'Yes' if cxx_standard.startswith('gnu++') else 'No',
            },
        ))

    root = 'config/cmake'
    paths.append(f'{path}/{root}')
    os.makedirs(f'{path}/{root}/toolchains')

    substitute_templates(
        template=f'{root}/add_targets.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/FindClangTidy.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/FindStdModules.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/add_packages.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/handle_options.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )
    substitute_templates(
        template=f'{root}/handle_options_impl.cmake',
        prefix=path,
        replace={'project_name': project_name},
    )

    target = 'x86_64'
    triple = 'x86_64-unknown-linux-gnu'
    toolchains = {
        'gcc': {
            'name': 'GCC',
            'toolchain': '',
            'triple': triple,
            'suffix': 'gcc',
        },
        'clang-gnu': {
            'name': 'Clang',
            'toolchain': ' (GNU toolchain)',
            'triple': triple,
            'suffix': 'with-gnu-toolchain'
        },
        'clang-llvm': {
            'name': 'Clang',
            'toolchain': ' (LLVM toolchain)',
            'triple': triple,
            'suffix': 'with-llvm-toolchain',
        }
    }
    gnu_toolchain = {
        'system_name': platform.system(),
        'target': target,
        'triple': triple,
        'prefix': toolchain_prefix,
        'cc': 'gcc',
        'cxx': 'g++',
        'ar': 'ar',
        'rc': 'rc',
        'ranlib': 'ranlib',
        'stdlib': '',
        'hardening': '',
        'libunwind': '',
        'compiler_rt': '',
        'linker': '-fuse-ld=gold',
        'exceptions': '-fno-exceptions' if not exceptions else '',
        'rtti': '-fno-rtti' if not rtti else '',
    }
    substitute_templates(rename=f'{make_triplet(toolchains["gcc"])}.cmake',
                         template=f'{root}/toolchains/toolchain_base.cmake',
                         prefix=path,
                         replace=gnu_toolchain)

    clang_with_gnu_toolchain = gnu_toolchain
    clang_with_gnu_toolchain['cc'] = 'clang'
    clang_with_gnu_toolchain['cxx'] = 'clang++'
    clang_with_gnu_toolchain['stdlib'] = '-stdlib=libstdc++'
    substitute_templates(
        rename=f'{make_triplet(toolchains["clang-gnu"])}.cmake',
        template=f'{root}/toolchains/toolchain_base.cmake',
        prefix=path,
        replace=clang_with_gnu_toolchain)

    llvm_toolchain = {
        'system_name': platform.system(),
        'target': target,
        'triple': triple,
        'prefix': toolchain_prefix,
        'cc': 'clang',
        'cxx': 'clang++',
        'ar': 'llvm-ar',
        'rc': 'llvm-rc',
        'ranlib': 'llvm-ranlib',
        'stdlib': '-stdlib=libc++',
        'hardening': '-D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_FAST',
        'libunwind': '-unwindlib=libunwind',
        'compiler_rt': '-rtlib=compiler-rt',
        'linker': '-fuse-ld=lld',
        'exceptions': '-fno-exceptions' if not exceptions else '',
        'rtti': '-fno-rtti' if not rtti else '',
    }
    substitute_templates(
        rename=f'{make_triplet(toolchains["clang-llvm"])}.cmake',
        template=f'{root}/toolchains/toolchain_base.cmake',
        prefix=path,
        replace=llvm_toolchain)

    if vcpkg_enabled:
        vcpkg_root = 'config/vcpkg/cmake/toolchains'
        paths.append(vcpkg_root)
        os.makedirs(f'{path}/{vcpkg_root}')

        triplet_name = 'triplet_name'
        gnu_toolchain[triplet_name] = make_triplet(toolchains['gcc'])
        clang_with_gnu_toolchain[triplet_name] = make_triplet(
            toolchains['clang-gnu'])
        llvm_toolchain[triplet_name] = make_triplet(toolchains['clang-llvm'])

        lto = 'lto'
        gnu_toolchain[lto] = '-flto'
        clang_with_gnu_toolchain[lto] = '-flto=thin'
        llvm_toolchain[lto] = '-flto=thin'

        substitute_templates(rename=f'{gnu_toolchain[triplet_name]}.cmake',
                             template=f'{vcpkg_root}/toolchain_base.cmake',
                             prefix=path,
                             replace=gnu_toolchain)
        substitute_templates(
            rename=f'{clang_with_gnu_toolchain[triplet_name]}.cmake',
            template=f'{vcpkg_root}/toolchain_base.cmake',
            prefix=path,
            replace=clang_with_gnu_toolchain)
        substitute_templates(rename=f'{llvm_toolchain[triplet_name]}.cmake',
                             template=f'{vcpkg_root}/toolchain_base.cmake',
                             prefix=path,
                             replace=llvm_toolchain)

    os.mkdir(f'{path}/source')
    shutil.copy('templates/source/CMakeLists.txt', f'{path}/source')
    paths.append('source')
    repo.index.add(paths)
    return toolchains


def generate_vcpkg(path: str, repo: Repo, project_name: str, remote: str):
    print('Acquiring vcpkg')
    if not remote:
        remote = 'https://github.com/Microsoft/vcpkg.git'
    vcpkg = Submodule.add(repo, 'vcpkg', path=f'{path}/vcpkg', url=remote)
    vcpkg.update(recursive=True, init=True, to_latest_revision=True)

    repo.index.add(
        substitute_templates(
            template='vcpkg.json',
            prefix=path,
            replace={'project_name': project_name},
        ))
